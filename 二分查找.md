# 二分查找
查找等于

	public int bsearch(int[] a,int target){
		int low=0;
		int high=a.length-1;
		while(low<=high){
			int mid=(high-low)/2+low;
			if(a[mid]<target){
				low=mid+1;
			}else if(a[mid]>target){
				high=mid-1;
			}else{
				return mid;
			}
		}
		return -1;
	}
	
查找第一个等于

	public int bsearch(int[] a,int target){
		int low=0;
		int high=a.length-1;
		while(low<=high){
			int mid=(high-low)/2+low;
			if(a[mid]<target){
				low=mid+1;
			}else if(a[mid]>target){
				high=mid-1;
			}else{
				if(mid==0||a[mid-1]!=target){
					return mid;
				}else{
					high=mid-1;
				}
			}
		}
		return -1;
	}

查找最后一个等于

	public int bsearch(int[] a,int target){
		int low=0;
		int high=a.length-1;
		while(low<=high){
			int mid=(high-low)/2+low;
			if(a[mid]<target){
				low=mid+1;
			}else if(a[mid]>target){
				high=mid-1;
			}else{
				if(mid==n.length-1||a[mid+1]!=target){
					return mid;
				}else{
					low=mid+1;
				}
			}
		}
		return -1;
	}
	
查找第一个大于等于

	public int bsearch(int[] a,int target){
		int low=0;
		int high=a.length-1;
		while(low<=high){
			int mid=(high-low)/2+low;
			if(a[mid]>=target){
				if(mid==0||a[mid-1]<target){
					return mid;
				}else{
					high=mid-1;
				}
			}else{
				low=mid-1;
			}
		}
		return -1;
	}
	
查找最后一个小于等于

	public int bsearch(int[] a,int target){
		int low=0;
		int high=a.length-1;
		while(low<=high){
			int mid=(high-low)/2+low;
			if(a[mid]<=target){
				if(mid==n.length-1||a[mid+1]>target){
					return mid;
				}else{
					low=mid+1;
				}
			}esle{
				high=mid-1;
			}
		}
		return -1;
	}
