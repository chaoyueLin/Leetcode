# 动态规划
动态规划问题的一般形式就是求最值。求解动态规划的核心问题是穷举。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。

动态规划的穷举有点特别，因为这类问题存在「重叠子问题」

动态规划问题一定会具备「最优子结构」

穷举所有可行解其实并不是一件容易的事，只有列出正确的「状态转移方程」，才能正确地穷举。

辅助你思考状态转移方程：
明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义。
## 背包问题

有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。

框架：

	int dp[N+1][W+1]
	dp[0][..]=0
	dp[..][0]=0
	for i in [1..N]:
		for w in [1..W]:
			dp[i][w]=max(
				把物品i放进背包，
				不把物品i放进背包
				)

	return dp[N][W]


代码：

	public static int getMaxValue(int[] weight, int[] value, int w, int n){
        int[][] table = new int[n + 1][w + 1];
        for (int i = 1; i <= n; i++) { //物品
            for (int j = 1; j <= w; j++) {  //背包大小
                if (weight[i] > j) {        
                        //当前物品i的重量比背包容量j大，装不下，肯定就是不装
                    table[i][j] = table[i - 1][j];
                    // System.out.print(table[i][j]+ " ");
                } else { //装得下，Max{装物品i， 不装物品i}
                    table[i][j] = Math.max(table[i - 1][j], table[i - 1][j - weight[i]] + value[i]);
                    //System.out.print(table[i][j]+ " ");
                }
            }
            // System.out.println();
        }
        return table[n][w];
    }

    
leetcode第416题分割等和子集

	public boolean canPartition(int[] nums) {
        int sum=0;
        for(int i=0;i<nums.length;i++){
            sum += nums[i];
        }
        if(sum %2 != 0){
            return false;
        }
        sum=sum/2;
        int n=nums.length;
        boolean [][] dp=new boolean [n+1][sum+1];
        for(int i=0;i<=n;i++){
            dp[i][0]=true;
        }
        for(int i=1;i<=n;i++){
            for(int j=1;j<=sum;j++){
                if(j-nums[i-1]<0){
                    dp[i][j]=dp[i-1][j];
                }else{
                    dp[i][j]=dp[i-1][j] | dp[i-1][j-nums[i-1]];
                }
            }
        }

        return dp[n][sum]; 
    }


leetcode第518，零钱兑换2

	public int change(int amount, int[] coins) {
        int n=coins.length;
        int [][] dp=new int[n+1][amount+1];
        for(int i=0;i<=n;i++){
            dp[i][0]=1;
        }
        for(int i=1;i<=n;i++){
            for(int j=1;j<=amount;j++){
                if(j-coins[i-1]<0){
                    dp[i][j]=dp[i-1][j];
                }else{
                    dp[i][j]=dp[i-1][j]+dp[i][j-coins[i-1]];
                }
            }
        }
        return dp[n][amount];
    }


## 子序列问题
解决两个字符串的动态规划问题，一般都是用两个指针 i,j 分别指向两个字符串的最后，然后一步步往前走，缩小问题的规模

	def dp(i, j):
	    dp(i - 1, j - 1) #1
	    dp(i, j - 1)     #2
	    dp(i - 1, j)     #3
### 编辑距离
leetcode第72题编辑距离

思路：

	if s1[i] == s2[j]:
	    啥都别做（skip）
	    i, j 同时向前移动
	else:
	    三选一：
	        插入（insert）
	        删除（delete）
	        替换（replace）

代码：

	public int minDistance(String word1, String word2) {
        int n=word1.length();
        int m=word2.length();
        int [][] dp=new int[n+1][m+1];
        for(int i=0;i<=n;i++){
            dp[i][0]=i;
        }
        for(int j=0;j<=m;j++){
            dp[0][j]=j;
        }

        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                if(word1.charAt(i-1)==word2.charAt(j-1)){
                    dp[i][j]=dp[i-1][j-1];
                }else{
                    dp[i][j]=min(dp[i][j-1]+1,dp[i-1][j]+1,dp[i-1][j-1]+1);
                }
            }
        }

        return dp[n][m];
    }

    public int min(int a,int b,int c){
        return Math.min(a,Math.min(b,c));
    }
